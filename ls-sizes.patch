From b3ef242d8dde158fca47b8a39a2791cfcbb8b121 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Sun, 15 Feb 2026 10:49:04 +0100
Subject: [PATCH 2/2] feat(cmd): Introduce "--sizes" to include sizes

The new parameter is not a bool flag and behaves as follows:

- "human": Prints "humanized" sizes
- "bytes": Prints the number of bytes without the measure unit
- Anything else: Prints nothing

Below is the updated help section.

NAME:
   car list - List the blocks in a car

USAGE:
   car list [command options]

OPTIONS:
   --verbose, -v            Show verbose information about contained blocks (default: false)
   --cids                   Include CIDs (default: true except for unixfs)
   --sizes value, -s value  Include sizes (specify "human" or "bytes") (default: human for verbose, none otherwise)
   --unixfs                 Show unixfs filesystem (full paths) (default: false)
   --help, -h               show help
---
 cmd/car/car.go  |   7 ++
 cmd/car/list.go | 182 +++++++++++++++++++++++++++++++++++-------------
 2 files changed, 141 insertions(+), 48 deletions(-)

diff --git a/cmd/car/car.go b/cmd/car/car.go
index 8c01a26..818ffe1 100644
--- a/cmd/car/car.go
+++ b/cmd/car/car.go
@@ -227,6 +227,13 @@ func main1() int {
 						Usage:       "Include CIDs",
 						DefaultText: "true except for unixfs",
 					},
+					&cli.StringFlag{
+						Name:        "sizes",
+						Aliases:     []string{"s"},
+						Usage:       "Include sizes (specify \"human\" or \"bytes\")",
+						Value:       "",
+						DefaultText: "human for verbose, none otherwise",
+					},
 					&cli.BoolFlag{
 						Name:  "unixfs",
 						Usage: "Show unixfs filesystem (full paths)",
diff --git a/cmd/car/list.go b/cmd/car/list.go
index 521ad95..6b11b2d 100644
--- a/cmd/car/list.go
+++ b/cmd/car/list.go
@@ -6,6 +6,7 @@ import (
 	"io"
 	"os"
 	"path"
+	"strings"
 
 	"github.com/dustin/go-humanize"
 	"github.com/ipfs/go-cid"
@@ -94,11 +95,16 @@ func ListCar(c *cli.Context) error {
 						if pbl.Name.Exists() {
 							name = pbl.Name.Must().String()
 						}
-						size := 0
+						fmt.Fprintf(outStream, "\t\t%s", name)
+
+						size := uint64(0)
 						if pbl.Tsize.Exists() {
-							size = int(pbl.Tsize.Must().Int())
+							size = uint64(pbl.Tsize.Must().Int())
+						}
+						sizePart := sizeStr(c, size)
+						if sizePart != "" {
+							fmt.Fprintf(outStream, "%s", sizePart)
 						}
-						fmt.Fprintf(outStream, "\t\t%s[%s]", name, humanize.Bytes(uint64(size)))
 
 						if c.Bool("cids") {
 							hsh := "<unknown>"
@@ -125,8 +131,8 @@ func ListCar(c *cli.Context) error {
 				}
 				fmt.Fprintf(outStream, "\tUnixfs %s\n", data.DataTypeNames[ufd.FieldDataType().Int()])
 			}
-		} else if c.Bool("cids") {
-			fmt.Fprintf(outStream, "%s\n", blk.Cid())
+		} else {
+			printEntry(c, blk.Cid(), "", uint64(len(blk.RawData())), outStream)
 		}
 	}
 
@@ -161,86 +167,166 @@ func listUnixfs(c *cli.Context, outStream io.Writer) error {
 		return err
 	}
 	for _, r := range roots {
-		if err := printUnixFSNode(c, "", r, &ls, outStream); err != nil {
+		if _, err := printUnixFSNode(c, "", r, &ls, outStream); err != nil {
 			return err
 		}
 	}
 	return nil
 }
 
-func printUnixFSNode(c *cli.Context, prefix string, node cid.Cid, ls *ipld.LinkSystem, outStream io.Writer) error {
-	// it might be a raw file (bytes) node. if so, not actually an error.
+func printUnixFSNode(c *cli.Context, prefix string, node cid.Cid, ls *ipld.LinkSystem, outStream io.Writer) (uint64, error) {
 	if node.Prefix().Codec == cid.Raw {
-		return nil
+		link := cidlink.Link{Cid: node}
+
+		rawBytes, err := ls.LoadRaw(
+			ipld.LinkContext{Ctx: c.Context},
+			link,
+		)
+
+		if err != nil {
+			return 0, err
+		}
+
+		return uint64(len(rawBytes)), nil
 	}
 
 	pbn, err := ls.Load(ipld.LinkContext{}, cidlink.Link{Cid: node}, dagpb.Type.PBNode)
 	if err != nil {
-		return err
+		return 0, err
 	}
 
 	pbnode := pbn.(dagpb.PBNode)
 
 	ufd, err := data.DecodeUnixFSData(pbnode.Data.Must().Bytes())
 	if err != nil {
-		return err
+		return 0, err
 	}
 
-	// only show CIDs if explicitly requested
-	printCids := c.IsSet("cids") && c.Bool("cids")
+	var totalSize uint64 = 0
 
-	if ufd.FieldDataType().Int() == data.Data_Directory {
+	switch ufd.FieldDataType().Int() {
+
+	case data.Data_Directory:
 		i := pbnode.Links.Iterator()
 		for !i.Done() {
-			_, l := i.Next()
-			name := path.Join(prefix, l.Name.Must().String())
-			if printCids {
-				cidL, _ := l.Hash.AsLink()
-				fmt.Fprintf(outStream, "%s %s\n", cidL.(cidlink.Link).Cid, name)
-			} else {
-				fmt.Fprintf(outStream, "%s\n", name)
+			_, link := i.Next()
+			name := link.Name.Must().String()
+			if name == "" {
+				continue
 			}
-			// recurse into the file/directory
-			cl, err := l.Hash.AsLink()
+
+			chPath := path.Join(prefix, name)
+
+			chLink, err := link.Hash.AsLink()
 			if err != nil {
-				return err
+				return 0, err
 			}
-			if cidl, ok := cl.(cidlink.Link); ok {
-				if err := printUnixFSNode(c, name, cidl.Cid, ls, outStream); err != nil {
-					return err
-				}
+
+			chCid := chLink.(cidlink.Link).Cid
+
+			chSize, err := printUnixFSNode(c, chPath, chCid, ls, outStream)
+			if err != nil {
+				return 0, err
 			}
 
+			totalSize += chSize
+
+			printEntry(c, chCid, chPath, chSize, outStream)
 		}
-	} else if ufd.FieldDataType().Int() == data.Data_HAMTShard {
+
+	case data.Data_HAMTShard:
 		hn, err := hamt.AttemptHAMTShardFromNode(c.Context, pbn, ls)
 		if err != nil {
-			return err
+			return 0, err
 		}
+
 		i := hn.Iterator()
 		for !i.Done() {
-			n, l := i.Next()
-			if printCids {
-				cl, _ := l.AsLink()
-				fmt.Fprintf(outStream, "%s %s\n", cl.(cidlink.Link).Cid, path.Join(prefix, n.String()))
-			} else {
-				fmt.Fprintf(outStream, "%s\n", path.Join(prefix, n.String()))
-			}
-			// recurse into the file/directory
-			cl, err := l.AsLink()
+			key, val := i.Next()
+
+			chPath := path.Join(prefix, key.String())
+
+			chLink, err := val.AsLink()
 			if err != nil {
-				return err
+				return 0, err
 			}
-			if cidl, ok := cl.(cidlink.Link); ok {
-				if err := printUnixFSNode(c, path.Join(prefix, n.String()), cidl.Cid, ls, outStream); err != nil {
-					return err
-				}
+
+			chCid := chLink.(cidlink.Link).Cid
+
+			chSize, err := printUnixFSNode(c, chPath, chCid, ls, outStream)
+			if err != nil {
+				return 0, err
 			}
+
+			totalSize += chSize
+
+			printEntry(c, chCid, chPath, chSize, outStream)
+		}
+
+	case data.Data_File:
+		size := uint64(0)
+		if ufd.FieldFileSize().Exists() {
+			size = uint64(ufd.FieldFileSize().Must().Int())
 		}
-	} else {
-		// file, file chunk, symlink, other un-named entities.
-		return nil
+
+		return size, nil
+
+	case data.Data_Raw:
+		size := uint64(0)
+		if ufd.FieldData().Exists() {
+			size = uint64(len(ufd.FieldData().Must().Bytes()))
+		}
+
+		return size, nil
+
+	default:
+		return 0, nil
 	}
 
-	return nil
+	return totalSize, nil
+}
+
+func printEntry(c *cli.Context, cid cid.Cid, path string, size uint64, outStream io.Writer) {
+	parts := make([]string, 0, 3)
+
+	if path != "" {
+		// For unixfs only show CIDs if explicitly requested
+		if c.IsSet("cids") && c.Bool("cids") {
+			parts = append(parts, cid.String())
+		}
+
+		parts = append(parts, path)
+	} else if c.Bool("cids") {
+		parts = append(parts, cid.String())
+	}
+
+	sizePart := sizeStr(c, size)
+	if sizePart != "" {
+		parts = append(parts, sizePart)
+	}
+
+	if len(parts) == 0 {
+		return
+	}
+
+	fmt.Fprintln(outStream, strings.Join(parts, " "))
+}
+
+func sizeStr(c *cli.Context, size uint64) string {
+	mode := ""
+
+	if c.IsSet("sizes") {
+		mode = c.String("sizes")
+	} else if c.Bool("verbose") {
+		mode = "human"
+	}
+
+	switch mode {
+	case "human":
+		return fmt.Sprintf("[%s]", humanize.Bytes(uint64(size)))
+	case "bytes":
+		return fmt.Sprintf("[%d]", size)
+	}
+
+	return ""
 }
-- 
2.51.2

